#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//浮点型在内存中的存储
//常见的浮点数：3.14159  1E10  
//浮点数家族包括：float,double,long double类型
//浮点数表示的范围：float.h中定义

//浮点数存储的例子：
int main()
{
	int n = 9;
	//00000000 00000000 00000000 00001001 - 补码 
	//0 00000000 00000000000000000001001
	float *pFloat = (float *)&n; //强制类型转换为float* (pFloat为指针)
	printf("n的值为:%d\n", n); //9
	printf("*pFloat的值为:%f\n", *pFloat); //0.000000
	//(-1)^0 * 0.00000000000000000001001 * 2^-126(无限接近于0)

	//十进制浮点表示9.0
	//以二进制浮点表示为1001.0
	//转换为(-1)^0 * 1.001 * 2^3
	//(-1)^S*M*2^E
	//S - 0
	//M - 1.001
	//E - 3

	*pFloat = 9.0;
	//1001.0
	//1.001 * 2^3
	//(-1)^0 * 1.001 *2^3
	//0 10000010 00100000000000000000000

	printf("num的值为:%d\n", n); //1091567616
	//补码等于原码,直接打印, 需要转换为十进制,结果为1091567616

	printf("*pFloat的值为:%f\n", *pFloat); //9.000000
	return 0;
}

//根据国际标准IEEE(电子和电子工程协会)754,任意一个二进制浮点数V可以表示成下面的形式:
//(-1)^S*M*2^E
//(-1)^s表示符号位,当s=0,V为整数;当s=1;V为负数
//M表示有效数字,大于等于1,小于2
//2^E表示指数位

//IEEE 754规定:对于32位的浮点数,最高的1位是符号位S,接着的8位是指数E,剩下的23位为有效数字M
//S(1bit)  E(8bit)  M(23bit)

//对于64位的浮点数,最高的1位是符号位S,接着的11位是指数E,剩下的52位为有效数字M

/*IEEE 754对有效数字M和指数E,还有一些特别规定
1<=M<=2,也就是说,M可以写成1.xxxxxx的形式,其中xxxxxx表示小数部分

IEEE 754规定,在计算机内部保存M时,默认这个数的第一位总是1,因此可以被舍去,只保存后面的xxxxxx部分

至于指数E,情况就比较复杂
首先,E为一个无符号整数(unsigned int)这意味着,如果E为8位,它的取值范围为0-255；
如果E为11位,它的取值范围为0-2047,但是科学计数法中的E是可以出现负数的,
所以IEEE 754规定,存入内存时E的真实值必须再加上一个中间数,对于8位的E,
这个中间数是127;对于11位的E,这个中间数是1023.
比如:2^10的E是10,所以保存成32位浮点数时,必须保存为10+127=137,即10001001
*/


//测试
int main()
{
	float f = 5.5;
	//5.5
	//101.1
	//(-1)^0 * 1.011 * 2^2
	//S = 0;
	//M = 1.011
	//E = 2
	//0100 0000 1011 0000 0000 0000 0000 0000
	//4    0    b    0    0    0    0    0(十六进制)
	//0x40b00000
	return 0;
}

//指数E从内存中取出还可以再分为三种情况:
//E不全为0或不全为1
/*
指数E的计算值减去127(或1023),得到真实值,再将有效数字M前加上第一位的1,
比如:0.5的二进制形式为0.1,由于规定正数部分必须为1,即将小数点右移一位,
则为1.0*2^(-1),其阶码为-1+127=126,表示为01111110,而尾数1.0去掉整数部分为0,
补齐0到23位00000000000000000000000,则其二进制表示形式为:
0 01111110 00000000000000000000000
*/

//E全为0
/*
0 00000000 01100000000000000000000
+/- 0.011 * 2^-126
这时,浮点数的指数E等于1-127(或者1-1023)即为真实值,有效数字M不再加上第一位的1,
而是还原为0.xxxxxx的小数.这样做是为了表示+/- 0,以及接近于0很小的数字
*/

//E全为1
/*
0 11111111 01100000000000000000000
E+127 = 255
E = 128
1.xxxxxx * 2^128
表示的正负无穷大的数字
这时,如果有效数字M全为0,表示+-无穷大(正负取决于符号位s)
*/

