#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<windows.h>

//整型在内存中的存储
int main()
{
	int a = 10;  //内存0a 00 00 00(32个二进制比特位转换为8个16进制)
	int b = -20;  //内存ec ff ff ff
	return 0;
}
//整型有符号数有三种表示形式：原码,反码,补码(无符号数的原码,反码,补码均相同)
//三种表示方法均有符号位和数值位两部分,符号位都是用0表示"正",用1表示"负",而数值位三种表示方法各不相同
//原码：直接将二进制按照正负数的形式翻译成二进制就可以
//反码：（负数）将原码的符号位不变,其他位依次按位取反就可以得到了
//补码：（负数）反码+1得到补码
//正数的原,反,补码都相同

//对于整型来说：数据存放内存中其实存放的是补码

int main()
{
	1 - 1;
	//计算机转化为1+(-1)
	//00000000000000000000000000000001 - 1的原码
	//10000000000000000000000000000001 - -1的原码
	//10000000000000000000000000000010  原码相加得到的结果不正确,原码相加是有问题的

	//利用补码
	//00000000000000000000000000000001
	//11111111111111111111111111111111
	//100000000000000000000000000000000  - 又因为只能存在32个比特位,所以结果为
	//00000000000000000000000000000000
	return 0;
}

int main()
{
	int a = 20;
	//00000000000000000000000000010100
	//0x00 00 00 14 但在内存中是倒着存入的, 14 00 00 00
	return 0;
}
//大端小端：
//大端(存储)模式,是指数据的低位保存在内存的高地址中,而数据的高位,保存在内存的低地址中; (00 00 00 14为大端存储)
//小端(存储)模式,是指数据的低位保存在内存的低地址中,而数据的高位,保存在内存的高地址中. (14 00 00 00为小端存储)

//百度2015年系统工程师笔试题:
//请简述大端字节序和小端字节序的概念,设计一个小程序来判断当前机器的字节序
int check_sys()
{
	int a = 1;
	char* p = (char*)&a;
	//返回1 - 小端   返回0 - 小端
	return *p;
	//return *(char*)&a;
}
int main()
{
	//写一段代码可知当前机器的字节序是什么
	//返回1 - 小端   返回0 - 大端
	int ret = check_sys();
	if (ret == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}

//练习
//1. 输出什么？
int main()
{
	char a = -1;
	//10000000000000000000000000000001  -  -1的原码
	//11111111111111111111111111111110  -  -1的反码
	//11111111111111111111111111111111  -  -1的补码
	//11111111 - char类型存8个比特位
	//下边打印整型时进行整型提升 11111111111111111111111111111111
	//再转换为原码,为10000000000000000000000000000001
	signed char b = -1;
	//11111111和char a同理
	unsigned char c = -1;
	//11111111
	//下边打印整型时进行整型提升 00000000000000000000000011111111
	//原码和补码相同,可以得255的结果
	printf("a=%d , b=%d , c=%d", a, b, c);  // -1  -1  255
	return 0;
}


//2.输出什么
int main()
{ 
	char a = -128;
	printf("%u\n", a);  //%u表示unsigned输出格式 - 打印十进制的无符号数字
	//10000000000000000000000001000000 - 原码
	//11111111111111111111111110111111 - 反码
	//11111111111111111111111111000000 - 补码
	//10000000 - char类型存放8格bit位
	//11111111111111111111111111000000 - 整型提升
	//11111111111111111111111111000000 - 因为输出的格式为%u,所以原码等于补码,为最终结果
	return 0;
}

//有符号的char的范围是: -128-->127
//无符号的char的范围是: 0-->255


//3.输出什么
int main()
{
	int i = -20;
	unsigned int j = 10;
	printf("%d\n", i + j); //按照补码的形式进行运算,最后格式化成为有符号整数
	//10000000 00000000 00000000 00010100 - 原码（-20）
	//11111111 11111111 11111111 11101011 - 反码
	//11111111 11111111 11111111 11101100 - 补码

	//00000000 00000000 00000000 00001010 - 原码（unsigned 10）
	//00000000 00000000 00000000 00001010 - 反码
	//00000000 00000000 00000000 00001010 - 补码

	//相加从低位开始算
	//11111111 11111111 11111111 11110110 - 结果（补码)
	//10000000 00000000 00000000 00001001 - 反码
	//10000000 00000000 00000000 00001010 - 输出的原码（结果为-10）
	return 0;
}


//4.输出什么
int main()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
		Sleep(100); //休息100ms - 执行挂起一段时间,也就是等待一段时间再继续执行
	}
	    
	//00000000 00000000 00000000 00001001 - 9
	//00000000 00000000 00000000 00001000 - 8
	//...
	//00000000 00000000 00000000 00000000 - 0(之后执行i--)
	//但因为i是无符号数,结果一定是非负的,程序执行之后打印死循环
	return 0;
}


//5.输出什么
int main()
{
	char a[1000];  //注意:char类型
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d\n", strlen(a));  //需要找\0停止(\0的asc码值为0)
	//a[]中放入的元素依次为-1,-2,-3,...,-128,127,126,...,2,1,0,...
	//因为是char类型,所有的元素都会转换为-128到127之间的数字
	//所以最终的输出结果为255
	return 0;
}

//6.输出什么
int main()
{
	unsigned char i = 0;  //存放数字的范围为0-255
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
	//死循环
}

