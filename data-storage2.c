#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//整型在内存中的存储
int main()
{
	int a = 10;  //内存0a 00 00 00(32个二进制比特位转换为8个16进制)
	int b = -20;  //内存ec ff ff ff
	return 0;
}
//整型有符号数有三种表示形式：原码,反码,补码(无符号数的原码,反码,补码均相同)
//三种表示方法均有符号位和数值位两部分,符号位都是用0表示"正",用1表示"负",而数值位三种表示方法各不相同
//原码：直接将二进制按照正负数的形式翻译成二进制就可以
//反码：（负数）将原码的符号位不变,其他位依次按位取反就可以得到了
//补码：（负数）反码+1得到补码
//正数的原,反,补码都相同

//对于整型来说：数据存放内存中其实存放的是补码

int main()
{
	1 - 1;
	//计算机转化为1+(-1)
	//00000000000000000000000000000001 - 1的原码
	//10000000000000000000000000000001 - -1的原码
	//10000000000000000000000000000010  原码相加得到的结果不正确,原码相加是有问题的

	//利用补码
	//00000000000000000000000000000001
	//11111111111111111111111111111111
	//100000000000000000000000000000000  - 又因为只能存在32个比特位,所以结果为
	//00000000000000000000000000000000
	return 0;
}

int main()
{
	int a = 20;
	//00000000000000000000000000010100
	//0x00 00 00 14 但在内存中是倒着存入的, 14 00 00 00
	return 0;
}
//大端小端：
//大端(存储)模式,是指数据的低位保存在内存的高地址中,而数据的高位,保存在内存的低地址中; (00 00 00 14为大端存储)
//小端(存储)模式,是指数据的低位保存在内存的低地址中,而数据的高位,保存在内存的高地址中. (14 00 00 00为小端存储)

//百度2015年系统工程师笔试题:
//请简述大端字节序和小端字节序的概念,设计一个小程序来判断当前机器的字节序
int check_sys()
{
	int a = 1;
	char* p = (char*)&a;
	//返回1 - 小端   返回0 - 小端
	return *p;
	//return *(char*)&a;
}
int main()
{
	//写一段代码可知当前机器的字节序是什么
	//返回1 - 小端   返回0 - 大端
	int ret = check_sys();
	if (ret == 1)
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}

//练习
//1. 输出什么？
int main()
{
	char a = -1;
	//10000000000000000000000000000001  -  -1的原码
	//11111111111111111111111111111110  -  -1的反码
	//11111111111111111111111111111111  -  -1的补码
	//11111111 - char类型存8个比特位
	//下边打印整型时进行整型提升 11111111111111111111111111111111
	//再转换为原码,为10000000000000000000000000000001
	signed char b = -1;
	//11111111和char a同理
	unsigned char c = -1;
	//11111111
	//下边打印整型时进行整型提升 00000000000000000000000011111111
	//原码和补码相同,可以得255的结果
	printf("a=%d , b=%d , c=%d", a, b, c);  // -1  -1  255
	return 0;
}


//2.输出什么
int main()
{ 
	char a = -128;
	printf("%u\n", a);  //%u表示unsigned输出格式 - 打印十进制的无符号数字
	//10000000000000000000000001000000 - 原码
	//11111111111111111111111110111111 - 反码
	//11111111111111111111111111000000 - 补码
	//10000000 - char类型存放8格bit位
	//11111111111111111111111111000000 - 整型提升
	//11111111111111111111111111000000 - 因为输出的格式为%u,所以原码等于补码,为最终结果
	return 0;
}

//有符号的char的范围是: -128-->127
//无符号的char的范围是: 0-->255